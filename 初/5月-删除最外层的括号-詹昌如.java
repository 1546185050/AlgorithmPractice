/*
有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。

如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。

示例 1:

输入："(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
示例 2：

输入："(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每隔部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
示例 3：

输入："()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。
*/

/*
*解题思路：对输入的非空字符串S进行遍历，通过设置标志位识别原语开始"("，结束")"，
*这里规定一个原语：flag=1表示该原语开始"(",flag自加来匹配，flag=0表示该原语结束")",flag自减来匹配，最后去掉原语最外层的括号，连接起来便是结果.
*
*此外：该题还可以通过堆栈来解决：思路：遍历输入的字符串，如果遍历的字符为s, 那么如果满足s != ')',就将遍历的s入栈，继续遍历，如果还是满足s != ')',并且栈中不止一个字符（要判断栈的长度是否大于1），就将s放在输出结果中,然后继续遍历，当s == ')',栈长度又大于1，此时说明有效字符串'()'配对成功，将栈顶元素弹出，放入结果中。以此下去，即可得到结果。
**/
import java.util.*;


public class removecode {

	public static String fun(String str) {
		int flag = 0; // 1. '(' ,0. ')'
		char[] ch = str.toCharArray();
		StringBuffer sb = new StringBuffer();
		for (char c: ch) {
			if (c == '(' && ++flag == 1) {
				continue;
			}else if (c == ')' && --flag == 0) {
				continue;
			}
			sb.append(c);
		}
		return sb.toString();
	}

	public static void main(String[] args) {
		System.out.println("please input a string:");
		Scanner in = new Scanner(System.in);
		String s = in.nextLine();
		String S = fun(s);
		System.out.println("S = " + S);
	}
}

/*
实例1：
please input a string:
(()())(())
S = ()()()

实例2：
please input a string:
(()())(())(()(()))
S = ()()()()(())

实例3：
please input a string:
()()
S =
*/
